use alloc::{string::ToString, vec::Vec};
use crypto::ElementHasher;
use math::FieldElement;
use utils::{ByteReader, ByteWriter, Deserializable, DeserializationError, Serializable, SliceReader};
use crate::{FriProof, FriProofLayer, VerifierError};

// Batched FRI PROOF
// ================================================================================================

/// A proof generated by a batched FRI prover.
///
/// A batched FRI proof consists of the following components:
///     - `fri_proof`: a FRI proof for the batched polynomial,
///     - `evaluations`: a vector containing the evaluations of the batched polynomial at 
///       all the query positions,
///     - `batching_proofs`: a vector of [FriProofLayer](crate) where each layer corresponds to a polynomial
///       to be batched in batched FRI. The layer stores the opening of that polynomial
///       at all the query positions,
///     - `layer_commitments`: a vector containing the commitments of all the FRI layers 
///     - `function_commitments`: a vector containing the commitments of all the polynomials to
///       be batched in batched FRI.
pub struct BatchedFriProof<H>
where 
    H: ElementHasher,
{
    fri_proof: FriProof,
    evaluations: Vec<u8>,
    batching_proofs: Vec<FriProofLayer>,
    layer_commitments: Vec<H::Digest>,
    function_commitments: Vec<H::Digest>,
} 

impl<H> BatchedFriProof<H>
where
    H: ElementHasher,
{
    pub(crate) fn new<E: FieldElement>(
        fri_proof: FriProof,
        evaluations: Vec<E>,
        batching_proofs: Vec<FriProofLayer>,
        layer_commitments: Vec<H::Digest>,
        function_commitments: Vec<H::Digest>
    ) -> Self {
        assert!(!batching_proofs.is_empty(), "The number of layers in batching_proofs must be greater than zero.");
        assert_eq!(function_commitments.len(), batching_proofs.len(), "The number of function commitments must equal the number of FriProofLayers in batching_proofs.");
        
        // Convert evaluations into a vector of bytes
        let mut evaluations_bytes = Vec::with_capacity(E::ELEMENT_BYTES * evaluations.len());
        evaluations_bytes.write_many(&evaluations);

        BatchedFriProof {
            fri_proof,
            evaluations: evaluations_bytes,
            batching_proofs,
            layer_commitments,
            function_commitments
        }
    }

    pub(crate) fn fri_proof(&self) -> &FriProof {
        &self.fri_proof
    }

    pub(crate) fn batching_proofs(&self) -> &[FriProofLayer] {
        &self.batching_proofs
    }

    pub(crate) fn layer_commitments(&self) -> &[H::Digest] {
        &self.layer_commitments
    }

    pub(crate) fn function_commitments(&self) -> &[H::Digest] {
        &self.function_commitments
    }

    /// Returns the number of the evaluation values in this proof.
    ///
    /// The number of evaluation values is computed by dividing the number of bytes 
    /// in `evaluations` by the size of the field element specified by `E` type parameter.
    pub fn num_evaluations<E: FieldElement>(&self) -> usize {
        self.evaluations.len() / E::ELEMENT_BYTES
    }

    /// Returns the number of bytes in this proof.
    pub fn size(&self) -> usize {
    
        let fri_proof_size = self.fri_proof.size();

        // +2 for number of bytes in evaluations
        let evaluations_size = self.evaluations.len() + 2;

        // +4 for number of batching proofs
        let batching_proofs_size = self.batching_proofs.iter().fold(4, |acc, layer| acc + layer.size());

        // +1 for number of layer commitments
        let layer_commitments_size = self.layer_commitments.iter().fold(1, |acc, commitment| {
            let commitment_size = commitment.get_size_hint();
            if commitment_size == 0 {
                panic!("The size of a layer commitment is 0");
            }
            acc + commitment_size
            }
        );

        // +4 for number of function commitments
        let function_commitments_size = self.function_commitments.iter().fold(4, |acc, commitment| {
            let commitment_size = commitment.get_size_hint();
            if commitment_size == 0 {
                panic!("The size of a function commitment is 0");
            }
            acc + commitment_size
            }
        );

        fri_proof_size + evaluations_size + batching_proofs_size + layer_commitments_size + function_commitments_size
    }


    // PARSING
    // --------------------------------------------------------------------------------------------

    /// Returns a vector of evaluations at the queried positions parsed from this proof.
    ///
    /// # Errors
    /// Returns an error if:
    /// * Any of the remainder values could not be parsed correctly.
    /// * Not all bytes have been consumed while parsing remainder values.
    pub fn parse_evaluations<E: FieldElement>(&self) -> Result<Vec<E>, VerifierError> {
        let num_elements = self.num_evaluations::<E>();
        
        let mut reader = SliceReader::new(&self.evaluations);
        let evaluations = reader.read_many(num_elements).map_err(|err| {
            VerifierError::InvalidValueInEvaluationsVector(err.to_string())
        })?;
        if reader.has_more_bytes() {
            return Err(VerifierError::UnconsumedBytesInEvaluationsVector);
        }
        Ok(evaluations)
    }
}

// SERIALIZATION / DESERIALIZATION
// ------------------------------------------------------------------------------------------------

impl<H> Serializable for BatchedFriProof<H>
where 
    H: ElementHasher
{
    /// Serializes `self` and writes the resulting bytes into the `target` writer.
    fn write_into<W: ByteWriter>(&self, target: &mut W) {
        // write FRI proof
        self.fri_proof.write_into(target);

        // write evaluations
        target.write_u16(self.evaluations.len() as u16);
        target.write_bytes(&self.evaluations);

        // write batching proofs
        target.write_u32(self.batching_proofs.len() as u32);
        for layer in self.batching_proofs.iter() {
            layer.write_into(target);
        }

        // write layer commitments
        target.write_u8(self.layer_commitments.len() as u8);
        for commitment in self.layer_commitments.iter() {
            commitment.write_into(target);
        }

        // write function commitments
        target.write_u32(self.function_commitments.len() as u32);
        for commitment in self.function_commitments.iter() {
            commitment.write_into(target);
        }
    }
}

impl<H> Deserializable for BatchedFriProof<H>
where 
    H: ElementHasher
{
    /// Reads a batched FRI proof from the specified `source` and returns the result.
    ///
    /// # Errors
    /// Returns an error if a valid proof could not be read from the source.
    fn read_from<R: ByteReader>(source: &mut R) -> Result<Self, DeserializationError> {
        // read FRI proof
        let fri_proof = FriProof::read_from(source)?;

        // read evaluations
        let num_evaluations_bytes = source.read_u16()? as usize;
        let evaluations = source.read_vec(num_evaluations_bytes)?;

        // read batching proofs
        let num_layers = source.read_u32()? as usize;
        let batching_proofs = source.read_many(num_layers)?;

        // read layer commitments
        let num_layer_commitments = source.read_u8()? as usize;
        let layer_commitments = source.read_many(num_layer_commitments)?;
        
        // read function commitments
        let num_function_commitments = source.read_u32()? as usize;
        let function_commitments = source.read_many(num_function_commitments)?;

        Ok(BatchedFriProof { 
            fri_proof, 
            evaluations, 
            batching_proofs, 
            layer_commitments, 
            function_commitments,
         })
    }
}

